package manifest

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/BurntSushi/toml"
)

const Filename = "aurora.toml"

// DeploysFilename is the hidden file that stores deploy state per profile. Generated by the CLI on deploy; do not edit.
const DeploysFilename = ".aurora.deploys.toml"

const deploysFileHeader = `# This file is generated and managed by the Aurora CLI. Do not edit.
# It stores the last deploy result per profile (contract_address, tx_hash, deployed_at).
# Regenerated on each deploy while keeping state for other profiles.

`

// Manifest is the parsed aurora.toml structure.
type Manifest struct {
	Project  Project                `toml:"project"`
	Profiles map[string]Profile     `toml:"profiles"`
	Deploys  map[string]DeployState `toml:"deploys"`
}

// DeployState holds the last deploy result for a profile. Written by the CLI on each deploy; do not edit by hand.
type DeployState struct {
	ContractAddress string `toml:"contract_address"`
	TxHash          string `toml:"tx_hash"`     // transaction hash of the deploy
	DeployedAt      string `toml:"deployed_at"` // RFC3339
}

// Project holds [project] section.
type Project struct {
	Name    string `toml:"name"`
	Version string `toml:"version"`
}

// Profile holds a profile section (e.g. [profiles.main]).
type Profile struct {
	Source  string `toml:"source"`
	Binary  string `toml:"binary"`
	RPC     string `toml:"rpc"`
	Privkey string `toml:"privkey"`
}

// FindProjectRoot returns the directory that contains aurora.toml, starting from the current directory and walking up. Returns an error if not found.
func FindProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	for {
		path := filepath.Join(dir, Filename)
		if _, err := os.Stat(path); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("%s not found in current directory or any parent (run 'aurora init' to create a project manifest)", Filename)
		}
		dir = parent
	}
}

// deploysFile is the structure of .aurora.deploys.toml (sections [deploys.<name>]).
type deploysFile struct {
	Deploys map[string]DeployState `toml:"deploys"`
}

// Load reads and parses the manifest from the given project root directory.
// Deploy state is read from .aurora.deploys.toml when present; aurora.toml is not modified for deploys.
func Load(projectRoot string) (*Manifest, error) {
	path := filepath.Join(projectRoot, Filename)
	var m Manifest
	if _, err := toml.DecodeFile(path, &m); err != nil {
		return nil, fmt.Errorf("decode %s: %w", path, err)
	}
	if m.Profiles == nil {
		m.Profiles = make(map[string]Profile)
	}
	m.Deploys = loadDeploysFile(projectRoot)
	if m.Deploys == nil {
		m.Deploys = make(map[string]DeployState)
	}
	return &m, nil
}

// loadDeploysFile reads .aurora.deploys.toml and returns the deploys map, or nil if the file is missing.
func loadDeploysFile(projectRoot string) map[string]DeployState {
	path := filepath.Join(projectRoot, DeploysFilename)
	var f deploysFile
	if _, err := toml.DecodeFile(path, &f); err != nil {
		return nil
	}
	if f.Deploys == nil {
		return nil
	}
	return f.Deploys
}

// Profile returns the named profile (e.g. "main") or an error if missing.
func (m *Manifest) Profile(name string) (Profile, error) {
	p, ok := m.Profiles[name]
	if !ok {
		return Profile{}, fmt.Errorf("profile %q not found in manifest", name)
	}
	return p, nil
}

// AbsPath returns path joined with project root (for source, binary).
func AbsPath(projectRoot, path string) string {
	if filepath.IsAbs(path) {
		return path
	}
	return filepath.Join(projectRoot, path)
}

// PersistDeploy writes the deploy result for the given profile to .aurora.deploys.toml. Existing deploy state for other profiles is preserved. Call after a successful deploy.
func PersistDeploy(projectRoot, profileName, address, deployTxHash, deployedAt string) error {
	path := filepath.Join(projectRoot, DeploysFilename)
	state := loadDeploysFile(projectRoot)
	if state == nil {
		state = make(map[string]DeployState)
	}
	state[profileName] = DeployState{
		ContractAddress: address,
		TxHash:          deployTxHash,
		DeployedAt:      deployedAt,
	}
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create %s: %w", DeploysFilename, err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			fmt.Fprintf(os.Stderr, "error closing %s: %v\n", DeploysFilename, err)
		}
	}()
	if _, err := f.WriteString(deploysFileHeader); err != nil {
		return fmt.Errorf("write %s header: %w", DeploysFilename, err)
	}
	enc := toml.NewEncoder(f)
	if err := enc.Encode(deploysFile{Deploys: state}); err != nil {
		return fmt.Errorf("encode %s: %w", DeploysFilename, err)
	}
	return nil
}
